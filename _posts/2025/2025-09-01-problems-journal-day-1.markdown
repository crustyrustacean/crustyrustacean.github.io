---
layout: post
title:  "The 99-Problems Journal: Day 1"
date:   2025-09-01 06:00:00 -0700
description: "Day 1 of the fresh approach to problem solving."
categories: [Problem Solving]
tags: [philosophy, framework, strategies]
---

> "Today is the first day of the rest of your life." - *Some Author I Can't Remember*

I've spent an embarrasing amount of time with ChatGPT 5 the last couple of weeks. I've been iterating with it on a problem solving discussion. I know it's wrong to use these tools for therapy, but it's been incredibly helpful to discuss a difficult (for me) topic without judgement.

<!--more-->

Believe me, if I'd engaged a person with this discussion, there would have been impatience and a whole lot of judgment.

## The Core Issue

For whatever reason, I never learned problem solving. I'm serious, I didn't. It was never modelled, never "shown" by a teacher, just generally missing from nearly 20 years of school. I'm finally starting to understand that now.

I just passed my 54th birthday.

It's high time to get this figured out so that I can, you know, *progress*.

## The Framework

This is the framework that's emerged from my two-week discussion:

### Core Structure (always the same)
- Input -> Transform -> Output
  - Every problem has something given, something that must happen, and something to produce.

👉 If you can identify these three, you’ve already cracked the “shape” of the problem.

### Archetypes (the building blocks)
- Nearly every problem reduces to one or more of these:
  - Counting → sum, total, frequency, length.
  - Comparing → bigger/smaller, earliest/latest, equal/different.
  - Transforming → reverse, change format, map to another form.
  - Constraints → rules, limits, boundaries, conditions.

👉 Big, scary problems are just stacked archetypes with extra “decoration”.

### Decoration Removal
- Problems often come with story, jargon, or fluff. Strip it down systematically:
  - Circle/underline nouns (inputs/objects) and verbs (actions).
  - Look for numbers or objects (they usually signal inputs).
  - Re-read the final question — that usually signals the output.
  - Watch for rules hiding in the text (constraints).

👉 If still stuck, build the toy case (smallest possible example).

### When Information Is Missing
- Real-world projects often don’t give enough info.
  - Acknowledge the gap.
  - Make explicit assumptions. (reasonable, minimal, written down).
  - Prototype anyway. Even a rough model gives feedback.
  - Refine with feedback. Assumptions invite clarification.

👉 Assumptions aren’t failure — they’re hypotheses to test.

### Messy First Steps (permission slips)
- Draft 0 is allowed. It can be clumsy.
- Motion > paralysis. Wrong moves give data; paralysis gives nothing.
- Brute force first. Elegance can come later.

👉 Treat every misstep as feedback, not wasted effort.

### Pseudocode as a Bridge
- Pseudocode is not formal -- it's a scaffold, use whatever format helps:
  - plain english: "split words, reverse, join"
  - loose pseudocode
  - near-code pseudocode
  - whatever!

👉 If you can read it tomorrow and still understand, it’s “right”.

### Boilerplate & Structure
- keep logic first (e.g. everything in `main.rs` at first).
- Write down boilerplate separately under a BOILERPLATE list (arg parsing, logging, etc.)
- only extract into modules later when:
  - a chunk > ~30 lines
  - it's reused
  - it changes for different reasons that the rest

### Reflection (to build fluency)
- After each attempt, jot 2-3 lines:
  - what I tried
  - what I learned
  - one archetype I used

👉 Over time, these notes become your proof that you’re building fluency.

## Mantras
- Paralysis is failure. Messy is progress.
- Every problem is just Input -> Transform -> Output + archetypes
- assumptions are not mistakes; they're testable hypotheses.

That's it, that's the framework.

Now the hard part...using it.
